/* Highest address of the user mode stack */
/*_estack = 0x20005000;    /* end of RAM */

/* Generate a link error if heap and stack don't fit into RAM */
_Min_Heap_Size = 0x0800;      /* required amount of heap  */
_Min_Stack_Size = 0x800; /* required amount of stack */


/* Memories definition */
MEMORY
{
  RAM (xrw)     : ORIGIN = 0x20000000, LENGTH = 64K
  ROM (rx)      : ORIGIN = 0x8000000, LENGTH = 256K
}

/* Sections */
SECTIONS
{
  /* The program code and other data into ROM memory */
  .text :
  {
    . = ALIGN(4); 
    *(.vectors)
    KEEP(*(.vectors))
    *(.text)           /* .text sections (code) */
    *(.text*)          /* all text section here */
  } >ROM

  /*
* These are the old initialisation sections, intended to contain
* naked code, with the prologue/epilogue added by crti.o/crtn.o
* when linking with startup files. The standalone startup code
* currently does not run these, better use the init arrays below.
*/
  .inits :           /*static constr and destr*/
  {
  /*перед тем, как начинать секцию, текущий адрес нужно выровнять по слову (4 байта).*/
    . = ALIGN(4); 
    KEEP(*(.init))
		KEEP(*(.fini))
		. = ALIGN(4);
    /* The preinit code, i.e. an array of pointers to initialisation 
     * functions to be performed before constructors. */
		PROVIDE_HIDDEN (__preinit_array_start = .);
    /* The init code, i.e. an array of pointers to static constructors. */
		PROVIDE_HIDDEN (__init_array_start = .);
		KEEP(*(SORT(.init_array.*)))
		KEEP(*(.init_array))
		PROVIDE_HIDDEN (__init_array_end = .);
    /*The fini code, i.e. an array of pointers to static destructors.*/
		PROVIDE_HIDDEN (__fini_array_start = .);
		KEEP(*(SORT(.fini_array.*)))
		KEEP(*(.fini_array))
		PROVIDE_HIDDEN (__fini_array_end = .);
		. = ALIGN(4);
    } >ROM

  /* Constant data into ROM memory*/
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)    
    *(vtable)					/* C++ virtual tables */
    /*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
    *(.glue_7)
    *(.glue_7t)
    _etext = .;
  } >ROM
  
  	/* Used by the startup to initialize data */
 _sidata = LOADADDR(.data);  
 
  .stack :              /* stack into start of RAM*/
	{
    . = ALIGN(4);
		_stack_begin = .;
		_StackLimit = _stack_begin + _Min_Stack_Size; /*for syscall*/  
		. = . + _Min_Stack_Size;
    _StackTop = .;
    PROVIDE(_estack = _StackTop);/*значение _estack устанавливаем в _StackTop*/ /*_stack в начало вектора*/
	}>RAM	  
      
	
  /* Initialized data sections into RAM memory */
  .data :
  {
    . = ALIGN(4);
    _sdata = .; /* STM specific definition */
    *(.data)           /* .data sections */
    *(.data*)
    _edata = . ;
    /*PROVIDE(current_ends = 0);*/
  } >RAM AT> ROM /*set data in ROM then in RAM in startup file*/

  /* Uninitialized data section into RAM memory fill zeroes in startup file*/
  . = ALIGN(4);
  .bss :
  {
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;  /* standard newlib definition */
    *(.bss)
    *(.bss*)
    *(COMMON)           /*uninitialize variables*/
    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss; /* standard newlib definition */
  } >RAM

  .heap :
	{
    . = ALIGN(4);
    _heap_start = __bss_end__;  
    /*PROVIDE(current_ends = 0);*/
    PROVIDE( end = . );                /*_sbrk uses end for malloc*/
		_heap_limit = _heap_start + _Min_Heap_Size;      
		. = . + _Min_Heap_Size;
    PROVIDE( _heap_end = . );    
	}>RAM 
}
